plugin.name=Zásuvný modul pro displej a vstup

adafruit.manual.name=AdaFruit_GFX s ruční deklarací a konfigurací
adafruit.manual.desc=Vykreslovat menu pomocí knihovny AdafruitGFX. Vytvořte si grafickou proměnnou a sami si ji nakonfigurujte. Zde nám jen sdělte název proměnné a její typ. Tato verze funguje s většinou displejů a je velmi konfigurovatelná.

adafruit.quickstart.name=AdafruitGFX šablona pro 5110, ST77xx a ILI9341
adafruit.quickstart.desc=Vykreslovat menu pomocí knihovny AdafruitGFX a naší šablony pro platformy Nokia 5110, ST77xx a ILI9341. Tato verze má rozumně výchozí mnohé konfigurační volby. Pro ty další použijte konfigurovatelný zásuvný modul Adafruit.
adafruit.quickstart.tab=Typ štítku pro ST7735
adafruit.quickstart.tab.desc=Když se používají displeje založené na ST7735, typová barva štítku obvykle označuje typ displeje
adafruit.quickstart.black.tab=Černý štítek
adafruit.quickstart.green.tab=Zelený štítek
adafruit.quickstart.red.tab=Červený štítek
adafruit.quickstart.mini.tab=Mini 160x80
adafruit.quickstart.hallowing.tab=Podsvícený

adafruit.mbed.oled.name=Adafruit OLED pro mbed
adafruit.mbed.oled.desc=AdafruitGFX OLED knihovna pro mbed zařízení. Tato verze funguje s displeji SSD1306 a SH1106. Můžete nastavit většinu parametrů a ve vašem kódu nepotřebujete nic definovat. Ohledně požadavků knihovny si prohlédněte dokumentaci.
adafruit.mbed.serial.bus=I2C nebo SPI reference
adafruit.mbed.serial.bus.desc=Název proměnné I2C nebo SPI objektu
adafruit.mbed.bus.type=Typ sériové sběrnice
adafruit.mbed.bus.type.desc=Typ sériové sběrnice. Buď I2C nebo SPI

adafruit.display.rotation=Otočení displeje (0..3)
adafruit.display.rotation.desc=Viz návod ke knihovně ohledně informací k rotaci

#
# dfRobot shield
#
dfrobot.uno.full=Uno (méně funkční) nebo Úplný (8K a více)
dfrobot.uno.full.desc=Uno (méně funkční/menší) nebo plně funkční zásuvný modul (rozdíl ~8K)
dfrobot.key.repeat=Rychlost opakování klávesy v počtu tiků (výchozí 20)
dfrobot.key.repeat.desc=Rychlost opakování klávesy pro tlačítka kodéru
dfrobot.lcd.name=Vykreslování pro DfRobot LCD shield
dfrobot.lcd.desc=Použít LCD panel na shieldu DfRobot přes knihovnu LiquidCrystalIO bez potřeby cokoli nastavovat.
dfrobot.keys.name=DfRobot vstup z joysticku shieldu
dfrobot.keys.desc=Použít spínače shieldu DfRobot k ovládání menu. Tyto spínače jsou připojeny na analogový vstup A0 a budou spravovány spínači.
dfrobot.use.right.as.sel=Použít pravé tlačítko pro výběr (uvolnit tlačítko pro výběr)
dfrobot.use.right.as.sel.desc=Použít pravé tlačítko namísto klávesy pro výběr. Ten se tak uvolní k použití jinde.

#
# UpDown buttons
#
updown.button.name=Ovládat menu tlačítky NAHORU a DOLŮ
updown.button.desc=Spínače, které představují akce nahoru, dolů a OK, ovládané knihovnou pro spínače. Tyto jsou plně debouncovány pull up nebo pull down spínače a mohou být připojeny přímo k Arduinu nebo i2c expandéru.

#
# Custom cases
#
custom.drawable.name=Generovat Drawable pro nepodporovaný grafický displej
custom.drawable.desc=Umožní vám napsat si vlastní kód (Drawable), který komunikuje s nepodporovaným displejem. Prohlédněte si dokumentaci.
complete.custom.display.name=Zcela přizpůsobené vykreslování od nuly
complete.custom.display.desc=Pokročilé použití knihovny (pro většinu grafických ovladačů preferujte customDrawable). Tato volba vám umožní napsat si vlastní kód pro vykreslování od nuly. Prohlédněte si dokumentaci.
complete.custom.header=Název hlavičkového souboru
complete.custom.header.desc=Soubor hlavičky potřebný pro kompilaci
complete.custom.class.name=Název vykreslovací třídy uvnitř hlavičky
complete.custom.class.name.desc=Název připravené vykreslovací třídy v této hlavičce

#
# UpDown buttons
#
updown.encoder.up.pin=Pin tlačítka Nahoru
updown.encoder.up.pin.desc=Pin, ke kterému je připojeno tlačítko NAHORU
updown.encoder.down.pin=Pin tlačítka Dolů
updown.encoder.down.pin.desc=Pin, ke kterému je připojeno tlačítko DOLŮ
updown.encoder.left.pin=Pin tlačítka Doleva/Zpět (-1 vypnuto)
updown.encoder.left.pin.desc=Připojení tlačítka Doleva nebo Zpět, nebo -1 pro žádné
updown.encoder.right.pin=Pin tlačítka Doprava/Další (-1 vypnuto)
updown.encoder.right.pin.desc=Připojení tlačítka Doprava nebo Další, nebo -1 pro žádné
updown.encoder.ok.pin=Pin tlačítka OK (-1 znamená DOPRAVA je OK)
updown.encoder.ok.pin.desc=Pin, ke kterému je připojeno OK. Když je -1, Doprava se stane OK

#
# LCD cases
#
lcd.char.width=Šířka Lcd
lcd.char.width.desc=Počet znaků napříč LCD
lcd.char.height=Výška Lcd
lcd.char.height.desc=Počet řádků na LCD
lcd.io.device=LCD IO zařízení (standardně prázdné)
lcd.io.device.desc=Toto vám umožňuje poskytnout IoAbstractionRef, pokud je váš displej připojen k nestandardnímu IO expandéru
lcd.backlight.pin=Volitelný pin pro podsvícení
lcd.backlight.pin.desc=Volitelný pin pro podsvícení nebo -1 pro žádné
lcd.pwm.contrast.pin=Volitelný pin pro PWM kontrast
lcd.pwm.contrast.pin.desc=Volitelný pin pro kontrast nebo -1 pro žádné. Prohlédněte si dokumentaci
lcd.i2c.addr=I2C adresa
lcd.i2c.addr.desc=Adresa, na které odpovídá displej
lcd.pin.layout=Rozložení pinů LCD
lcd.pin.layout.desc=Jak jsou uspořádány piny
lcd.wire.variable=Proměnná I2C (Wire)
lcd.wire.variable.desc=Název instance I2C, která se má použít (standardně Wire)

#
# SSD1306ascii
#
ssd1306ascii.name=Přizpůsobitelný modul SSD1306ASCII pro ruční konfiguraci
ssd1306ascii.desc=SSD1306ASCII používá greiman SSD1306Asci z githubu ke generování vykreslovače pro OLED zařízení s pevnou šířkou písma, který využívá málo paměti. Upozornění pro komerční použití: knihovna SSD1306Ascii je GPL
ssd1306ascii.char.width=Počet znaků horizontální
ssd1306ascii.char.width.desc=Počet znaků napříč displejem
ssd1306ascii.item.font=Monospace písmo pro položky
ssd1306ascii.item.font.desc=Písmo, které se použije pro vykreslování položek menu
ssd1306ascii.title.font=Písmo pro titul
ssd1306ascii.title.font.desc=Písmo, které se použije pro titul

#
# Frame buffer / LTDC
#
ltdc.driver.name=STM32 LTDC frame buffer (volitelná podpora dotyků) pomocí BSP funkcí
ltdc.driver.desc=Používá BSP ovladač od ST Microelectronics jako buffer displeje LTDC a volitelně také jako podporu pro BSP dotykovou obrazovku. Tento ovladač je pouze pro desky STM32 při použití s mbed nebo Stm32Duino a vyžaduje značnou konfiguraci.

#
# ESP32 touch sensor
#
esp32.sensor.name=Použít touchpad senzory z ESP32 pro vstup
esp32.sensor.desc=Interaguje s touchpad senzory z ESP32 a použije je jako tlačítka se spínači. Je podporován režim přes přerušení nebo polling.
esp32.sensor.threshold=Prah pro aktivaci spínače
esp32.sensor.threshold.desc=Bod nad/pod, kde se spínač považuje za stlačený
esp32.sensor.threshold.mode=Režim aktivace prahu
esp32.sensor.threshold.mode.desc=Je-li spouštěč pod nebo nad prahovou hodnotou
esp32.sensor.low.voltage=Nízkonapěťové nastavení
esp32.sensor.low.voltage.desc=Nízkonapěťové nastavení pro použití s touchpadem
esp32.sensor.high.voltage=Vysokonapěťové nastavení
esp32.sensor.high.voltage.desc=Vysokonapěťové nastavení pro použití s touchpadem
esp32.sensor.attenuation=Nastavení útlmu
esp32.sensor.attenuation.desc=Nastavení útlmu pro použití s touchpadem
esp32.sensor.up=Číslo senzoru Nahoru
esp32.sensor.up.desc=Dotykový senzor pro NAHORU
esp32.sensor.down=Číslo senzoru Dolů
esp32.sensor.down.desc=Dotykový senzor pro DOLŮ
esp32.sensor.left=Číslo senzoru Doleva (-1 vypnuto)
esp32.sensor.left.desc=Dotykový senzor pro DOLEVA nebo -1 pro žádný
esp32.sensor.right=Číslo senzoru Doprava (-1 vypnuto)
esp32.sensor.right.desc=Dotykový senzor pro DOPRAVA nebo -1 pro žádný
esp32.sensor.sel=Číslo senzoru pro výběr (-1 používá DOPRAVA)
esp32.sensor.sel.desc=Senzor pro výběr nebo pokud -1, Doprava se použije jako výběr

#
# Java cases
#
java.includes.openjfx=Moje JDK obsahuje OpenJFX
java.includes.openjfx.desc=V případě, že vaše JDK již obsahuje knihovny OpenJFX, například Liberica

#
# Touch screens
#
touch.res.xp=X+ pin
touch.res.xn=X-pin (musí být ADC)
touch.res.yp=Y+ pin (musí být ADC)
touch.res.yn=Y-pin
touch.res.xp.desc=Nastavit na X+ pin
touch.res.xn.desc=Nastavit na X-pin, musí být ADC pin
touch.res.yp.desc=Nastavit na Y+ pin, musí být ADC pin
touch.res.yn.desc=Nastavit na Y-pin
touch.res.name=Rezistivní dotyková obrazovka na analogových vstupech
touch.res.desc=Rezistivní panel dotykové obrazovky, který je připojen k displeji. Tento ovladač řeší přímé připojení k analogovým pinům zařízení a musí se používat s grafickým vykreslovačem.
touch.lib.name=Modul pro dotykové obrazovky FT6206/XPT2046, který poskytuje integraci s knihovnou
touch.lib.desc=Moduly pro dotykové obrazovky FT6206/XPT2046, které se integrují buď s knihovnou FT6206 od firmy Adafruit nebo XPT2046 od Paula Stoffregena. Fungují s velkým množstvím dotykových obrazovek.
touch.lib.prop=Dotyková knihovna (musí být nainstalována)
touch.lib.prop.desc=Dotyková knihovna, která podporuje dotykové zařízení. Knihovna musí být nainstalována
touch.tft.use.raw=Použít TFT_eSPI přímou funkci
touch.tft.use.raw.desc=Použít přímé funkční volání k získání nekalibrované hodnoty z knihovny TFTeSPI
touch.tft.calib.width=Maximální šířka podporovaná dotykovou funkcí
touch.tft.calib.width.desc=Maximální šířka, která bude oznámena po zavolání dotykových funkcí TFT_eSPI
touch.tft.calib.height=Maximální výška oznámená dotykovou funkcí
touch.tft.calib.height.desc=Maximální výška, která bude oznámena po zavolání dotykových funkcí TFT_eSPI

#
# U8G2 displeje
#
u8g2.yield.callback=Zlepšit latenci I2C volání vlastním byte callbackem
u8g2.yield.callback.desc=Nahradí byte callback, který často volá yieldForMicros, a tím zlepší latenci. Sami si musíte zavolat Wire.begin()
u8g2.enable.utf8=Zapnout podporu pro UTF-8
u8g2.enable.utf8.desc=Když je to zapnuto, budeme dělat volání do U8G2 pomocí UTF8 funkcí. Pokud ne, použijeme obyčejný print

#
# Core values used by all entries in plugin
#
core.display.variable=Proměnná displeje
core.display.variable.desc=Název proměnné displeje přesně tak, jak je deklarována ve skeči
core.display.variable.auto.desc=Název proměnné displeje, která se vytvoří
core.display.variable.type=Typ proměnné displeje
core.display.variable.type.desc=Typ proměnné displeje AdaGfx (šablona ji vytvoří za vás, jinak se deklaruje ve skeči)
core.display.config=Konfigurace displeje (běžně se nevyplňuje)
core.display.config.desc=Historické nastavení pro ty, kteří nezmigrovali na motivy
core.display.is.buffered=Displej je bufferován v paměti (EG OLED)
core.display.is.buffered.desc=Zda je knihovna displeje nabufferována v paměti
core.display.width=Šířka displeje
core.display.width.desc=Šířka hardwaru v pixelech
core.display.height=Výška displeje
core.display.height.desc=Výška hardwaru v pixelech
core.reset.pin=Volitelný reset pin
core.reset.pin.desc=Možnost zadat pin, ke kterému je připojen Reset
core.cs.pin=CS pin (pouze pro SPI)
core.cs.pin.desc=Možnost zadat pin, ke kterému je připojen CS
core.rs.pin=RS/DC pin (pouze pro SPI)
core.rs.pin.desc=Možnost zadat pin, ke kterému je připojen RS/DC
core.option.data.pin=Datový pin (pouze pro SW SPI/I2C)
core.option.data.pin.desc=Volitelně specifikuje datový pin pro SW SPI/I2C
core.option.clock.pin=Pin s hodinovými impulsy (pouze pro SW SPI/I2C)
core.option.clock.pin.desc=Volitelně specifikuje pin s hodinovými impulsy pro SW SPI/I2C
core.screen.updates.sec=Aktualizací obrazovky za sekundu
core.screen.updates.sec.desc=Počet aktualizací obrazovky za sekundu. Ujistěte se, že je dělitelný 1000
core.display.buffer.size=Kolik řádků bufferovat (zvýšení výkonu) (zhruba 40-80 bajtů na řádek)
core.display.buffer.size.desc=Větší výkon a méně blikání. Vykresluje položky do paměťového zásobníku a poté volitelně zapíše výsledek na TFT (také zvané Sprite height)
core.input.polling=Režim pollingu / přerušení
core.input.polling.desc=Vyberte, zda budou spínače používat polling / přerušení
core.input.polling.all=Polling pro klávesy a kodéry
core.input.polling.none=Vše je řízeno přerušeními
core.input.polling.keys=Klávesy používají polling, pin kodéru A přerušení
core.switch.io.device=IoAbstractionRef pro spínače
core.switch.io.device.desc=Toto vám umožní poskytnout IoAbstractionRef, pokud máte vstup na IO expandéru
core.key.repeat.speed=Rychlost opakování kláves v počtu tiků (standardně 20)
core.key.repeat.speed.desc=Rychlost opakování kláves pro tlačítka kodéru
core.pullup.logic=PullUp logika
core.pullup.logic.desc=Toto zapněte, aby se použila pull up logika. Jinak se použije pull down
core.no.display=Nevyžaduje se žádný displej
core.no.display.desc=Toto použijte tehdy, pokud chcete použít vlastní technologii displeje nebo ve vašem zařízení není žádný displej.
core.no.input=Nevyžaduje žádný vstup
core.no.input.desc=Tuto možnost použijte tehdy, pokud nemáte žádné lokální vstupy nebo je vstup kombinován s modulem displeje.
core.touch.separator=Volitelná nastavení dotyků
core.touch.separator.desc=Volitelná nastavení pro dotykový ovladač poskytnutý knihovnou
core.touch.required=Vyžaduje se dotyková obrazovka
core.touch.required.desc=Nastavte na true, abyste zapnuli podporu pro dotykové obrazovky
core.touch.orientation=Orientace dotyků
core.touch.orientation.desc=Volitelná nastavení orientace dotyků
core.touch.swap.xy=Orientace spínače z X,Y do Y,X
core.touch.swap.xy.desc=V případě potřeby zamění orientaci dotykové obrazovky z X,Y na Y,X
core.touch.x.inverted=Invertovat hodnoty v nezpracovaném rozměru X
core.touch.x.inverted.desc=Invertuje nezpracovanou rovinu X na dotykové obrazovce (před aplikováním orientace)
core.touch.y.inverted=Invertovat hodnoty v nezpracovaném rozměru Y
core.touch.y.inverted.desc=Invertuje nezpracovanou rovinu Y na dotykové obrazovce (před aplikováním orientace)
core.touch.calibration=Volitelná kalibrace dotyků
core.touch.calibration.desc=Volitelná nastavení dotyků
core.enable.touch.calib=Povolit kalibraci dotyků
core.enable.touch.calib.desc=Povolit interní kalibraci dotyků, včetně kalibrace UI
core.touch.calib.addr=Umístění v EEPROM pro uložení kalibrace
core.touch.calib.addr.desc=Umístění v EEPROM, kde se začnou ukládat data kalibrace
