package com.thecoderscorner.menu.editorui.generator.font;

import java.io.IOException;
import java.io.OutputStream;
import java.io.PrintStream;
import java.nio.ByteBuffer;
import java.time.LocalDateTime;
import java.util.List;
import java.util.stream.Collectors;

public record TcUnicodeFontExporter(String fontName, List<TcUnicodeFontBlock> blocks, int yAdvance) implements FontEncoder {
    List<TcUnicodeFontGlyph> itemsFromAllBlocks() {
        return blocks.stream().flatMap(b -> b.glyphs().stream()).collect(Collectors.toList());
    }
    @Override
    public void encodeFontToStream(OutputStream stream, FontFormat fmt) throws IOException {
        var ps = new PrintStream(stream);
        ps.println("// Font file generated by theCodersCorner.com Font Generator on " + LocalDateTime.now());
        ps.println("#include " + includeFileForFormat(fmt));
        ps.println();
        ps.println("const uint8_t " + fontName + "Bitmaps[] PROGMEM {");
        List<TcUnicodeFontGlyph> allGlyphs = itemsFromAllBlocks();
        printByteArray(ps, allGlyphs);
        ps.println("};");
        ps.println();
        var blockData = new StringBuilder(255);
        if(fmt == FontFormat.TC_UNICODE) {
            boolean firstBlock = true;
            for(var block : blocks) {
                if(!firstBlock) {
                    ps.println(",");
                }
                firstBlock = false;
                ps.println("const UnicodeFontBlock " + fontName + "Blocks[] PROGMEM = {");
                ps.printf("    {%d, %s, %d}", block.mapping().getStartingCode(),  block.mapping(),
                        block.mapping().getEndingCode() - block.mapping().getStartingCode());
                ps.println();
                ps.println("};");

            }

            ps.println("const UnicodeFontGlyph " + fontName + "Glyphs[] PROGMEM = {");
            int bmpOffset = 0;
            boolean first = true;
            for(var item : items) {
                if(!first) {
                    ps.println(",");
                }
                first = false;
                ps.printf("{ %d, %d, %d, %d, %d, %d, %d}", item.charNum(), bmpOffset, item.width(),
                        item.height(), item.xAdvance(), item.xOffset(), item.yOffset());
                bmpOffset += item.bitmapData().length;
            }
            ps.println();
            ps.println("};");
            ps.println();
            ps.println("const UnicodeFont " + fontName + "[] PROGMEM = {");
            ps.println("    " + fontName + "Bitmaps;");
            ps.println("    " + fontName + "Glyphs;");
            ps.println("    " + yAdvance);
            ps.println("};");
        } else {
            if(!checkAdafruitValidity(allGlyphs)) throw new IOException("Font characters are not sequential");
            ps.println("const GFXglyph " + fontName + "Glyphs[] PROGMEM = {");
            int min = allGlyphs.get(0).charNum();
            int max = allGlyphs.stream().map(TcUnicodeFontGlyph::charNum).reduce(0, Integer::max);

            int bmpOffset = 0;
            boolean first = true;
            for(var item : allGlyphs) {
                if(!first) {
                    ps.println(",");
                }
                first = false;
                ps.printf("    { %d, %d, %d, %d, %d, %d } /* %d */", bmpOffset, item.width(),
                        item.height(), item.xAdvance(), item.xOffset(), item.yOffset(), item.charNum);
                bmpOffset += item.bitmapData().length;
            }
            ps.println();
            ps.println("};");
            ps.println();
            ps.println("const GFXfont " + fontName + " PROGMEM = {");
            ps.println("    (uint8_t*)" + fontName + "Bitmaps;");
            ps.println("    (GFXglyph*)" + fontName + "Glyphs;");
            ps.println("    " + min + ", " + max + ",");
            ps.println("    " + yAdvance);
            ps.println("};");
        }
        ps.println();
    }

    private boolean checkAdafruitValidity(List<TcUnicodeFontGlyph> allGlyphs) {
        int last = -1;
        for(var g : allGlyphs) {
            if(last != -1) {
                if(g.charNum() != (last + 1)) return false;
            }
            last = g.charNum();
        }
        return true;
    }

    private String includeFileForFormat(FontFormat fmt) {
        return switch (fmt) {
            case ADAFRUIT -> "<gfxfont.h>";
            case TC_UNICODE -> "<graphics/UnicodeFontHandler.h>";
        };
    }

    private void printByteArray(PrintStream ps, List<TcUnicodeFontGlyph> glyphs) {
        int dataSize = glyphs.stream().map(i -> i.bitmapData().length).reduce(0, Integer::sum);
        byte[] dataBytes = new byte[dataSize];
        int current = 0;
        for(var item : glyphs) {
            for(int i=0; i<item.bitmapData().length; i++) {
                dataBytes[current + i] = item.bitmapData()[i];
            }
            current += item.bitmapData().length;
        }

        for(int i = 0; i< dataBytes.length; i++) {
            ps.append(String.format("0x%02x", dataBytes[i]));
            if(i != (dataBytes.length -1)) {
                ps.append(",");
            }
            else {
                ps.append("\n");
            }

            if((i%20)==19) {
                ps.append("\n");
            }
        }
    }

    public ByteBuffer encodeFontAsByteArray(FontFormat fmt) {
        throw new UnsupportedOperationException();
    }

    public record TcUnicodeFontGlyph(int charNum, byte[] bitmapData, int width, int height, int xAdvance, int xOffset, int yOffset) {
    }

    public record TcUnicodeFontBlock(UnicodeBlockMapping mapping, List<TcUnicodeFontGlyph> glyphs) {
    }
}
