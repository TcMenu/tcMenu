package com.thecoderscorner.menu.editorui.generator.font;

import java.io.OutputStream;
import java.io.PrintStream;
import java.nio.ByteBuffer;
import java.time.LocalDateTime;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.stream.Collectors;

import static com.thecoderscorner.menu.editorui.generator.core.CoreCodeGenerator.LINE_BREAK;
import static com.thecoderscorner.menu.editorui.util.StringHelper.printArrayToStream;

public record TcUnicodeFontExporter(String fontName, List<TcUnicodeFontBlock> blocks, int yAdvance) implements FontEncoder {
    List<TcUnicodeFontGlyph> itemsFromAllBlocks() {
        return blocks.stream().flatMap(b -> b.glyphs().stream()).collect(Collectors.toList());
    }
    @Override
    public void encodeFontToStream(OutputStream stream, FontFormat fmt) {
        var ps = new PrintStream(stream);
        ps.println("// Font file generated by theCodersCorner.com Font Generator on " + LocalDateTime.now());
        ps.println("#include " + includeFileForFormat(fmt));
        ps.println();
        ps.println("const uint8_t " + fontName + "Bitmaps[] PROGMEM {");
        List<TcUnicodeFontGlyph> allGlyphs = itemsFromAllBlocks();
        printByteArray(ps, allGlyphs);
        ps.println("};");
        ps.println();
        switch(fmt) {
            case ADAFRUIT -> encodeAdafruit(ps, allGlyphs);
            case TC_UNICODE -> encodeTcUnicode(ps);
        }
    }

    private void encodeAdafruit(PrintStream ps, List<TcUnicodeFontGlyph> allGlyphs) {
        ps.println("const GFXglyph " + fontName + "Glyphs[] PROGMEM = {");
        int min = allGlyphs.get(0).charNum();
        int max = allGlyphs.stream().map(TcUnicodeFontGlyph::charNum).reduce(0, Integer::max);

        int bmpOffset = 0;
        boolean first = true;
        for(var item : allGlyphs) {
            if(!first) {
                ps.println(",");
            }
            first = false;
            ps.printf("    { %d, %d, %d, %d, %d, %d } /* %s %d */", bmpOffset, item.width(),
                    item.height(), item.xAdvance(), item.xOffset(), item.yOffset(),
                    Arrays.toString(Character.toChars(item.charNum())), item.charNum());
            bmpOffset += item.bitmapData().length;
        }
        ps.println();
        ps.println("};");
        ps.println();
        ps.println("const GFXfont " + fontName + " PROGMEM = {");
        ps.println("    (uint8_t*)" + fontName + "Bitmaps,");
        ps.println("    (GFXglyph*)" + fontName + "Glyphs,");
        ps.println("    " + min + ", " + max + ",");
        ps.println("    " + yAdvance);
        ps.println("};");
        ps.println();
    }

    private void encodeTcUnicode(PrintStream ps) {
        var blockData = new ArrayList<String>();
        for(var block : blocks) {
            blockData.add(String.format("    {%d, %s, %d} /* %s */",
                    block.mapping().getStartingCode(),  fontName + "Glyphs_" + block.mapping().ordinal(),
                    block.mapping().getEndingCode() - block.mapping().getStartingCode(), block.mapping()));

            ps.println("// Glyphs for " + block.mapping());
            ps.printf("const UnicodeFontGlyph %sGlyphs_%d[] PROGMEM = {", fontName, block.mapping().ordinal());
            ps.println();

            int bmpOffset = 0;
            boolean first = true;
            for(var item : block.glyphs()) {
                if(!first) {
                    ps.println(",");
                }
                first = false;
                ps.printf("{ %d, %d, %d, %d, %d, %d, %d} /* %s %d*/ ", item.charNum(), bmpOffset, item.width(),
                        item.height(), item.xAdvance(), item.xOffset(), item.yOffset(),
                        Arrays.toString(Character.toChars(item.charNum())), item.charNum());
                bmpOffset += item.bitmapData().length;
            }
            ps.println();
            ps.println("};");
            ps.println();
        }

        ps.println("const UnicodeFontBlock " + fontName + "Blocks[] PROGMEM = {");
        ps.println(blockData.stream().collect(Collectors.joining("," + LINE_BREAK)));
        ps.println("};");
        ps.println();

        ps.println("const UnicodeFont " + fontName + "[] PROGMEM = {");
        ps.println("    " + fontName + "Bitmaps,");
        ps.println("    " + fontName + "Blocks,");
        ps.println("    " + yAdvance);
        ps.println("};");
        ps.println();
    }

    private String includeFileForFormat(FontFormat fmt) {
        return switch (fmt) {
            case ADAFRUIT -> "<gfxfont.h>";
            case TC_UNICODE -> "<graphics/UnicodeFontHandler.h>";
        };
    }

    private void printByteArray(PrintStream ps, List<TcUnicodeFontGlyph> glyphs) {
        int dataSize = glyphs.stream().map(i -> i.bitmapData().length).reduce(0, Integer::sum);
        byte[] dataBytes = new byte[dataSize];
        int current = 0;
        for(var item : glyphs) {
            System.arraycopy(item.bitmapData(), 0, dataBytes, current, item.bitmapData().length);
            current += item.bitmapData().length;
        }

        printArrayToStream(ps, dataBytes, 20);
    }

    public ByteBuffer encodeFontAsByteArray(FontFormat fmt) {
        throw new UnsupportedOperationException();
    }

    public record TcUnicodeFontGlyph(int charNum, byte[] bitmapData, int width, int height, int xAdvance, int xOffset, int yOffset) {
    }

    public record TcUnicodeFontBlock(UnicodeBlockMapping mapping, List<TcUnicodeFontGlyph> glyphs) {
    }
}
